export class HttpAdapter{
  constructor(opts){ this.url = (opts&&opts.url)||''; this.method = (opts&&opts.method)||'PUT'; this.headers = (opts&&opts.headers)||{}; this.snapshotUrl = (opts&&opts.snapshotUrl)||this.url }
  async read(){ const ah = Object.assign({}, this.headers); const r = await fetch(this.snapshotUrl||this.url,{ cache:'no-store', mode:'cors', credentials:'omit', headers: ah }); if(!r.ok) return []; const et=r.headers.get('etag'); if(et) window.cedbEtag = et; const t=await r.text(); try{ return JSON.parse(t) }catch(_){ return [] } }
  async write(data, opts){ const body = JSON.stringify(data,null,2); let et=''; try{ const head = await fetch(this.url,{ method:'HEAD' }); et = head.headers.get('etag')||'' }catch(_){ et='' } const hdrs = Object.assign({ 'Content-Type':'application/json' }, this.headers, et? { 'If-Match': et } : {}, (opts&&opts.allowEmpty)? { 'X-Allow-Empty-Write':'true' } : {}); const r = await fetch(this.url,{ method: this.method, headers: hdrs, body, mode:'cors', credentials:'omit' }); if(r.status===412) throw new Error('precondition_failed'); if(r.status===429) throw new Error('rate_limited'); if(!r.ok) throw new Error('write_failed'); const newEt=r.headers.get('etag'); if(newEt) window.cedbEtag = newEt; return true }
}

export class IndexedDBAdapter{ constructor(name){ this.name=name||'coreenginedb'; this.store='records' } async open(){ return new Promise((res,rej)=>{ const r=indexedDB.open(this.name,1); r.onupgradeneeded=()=>{ const db=r.result; if(!db.objectStoreNames.contains(this.store)) db.createObjectStore(this.store,{ keyPath:'id' }) }; r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error) }) } async read(){ const db=await this.open(); return new Promise((res,rej)=>{ const tx=db.transaction(this.store,'readonly'); const st=tx.objectStore(this.store); const req=st.getAll(); req.onsuccess=()=>res(Array.isArray(req.result)?req.result:[]); req.onerror=()=>rej(req.error) }) } async write(data){ const db=await this.open(); return new Promise((res,rej)=>{ const tx=db.transaction(this.store,'readwrite'); const st=tx.objectStore(this.store); const clr=st.clear(); clr.onsuccess=()=>{ try{ (Array.isArray(data)?data:[]).forEach(row=>st.put(row)) }catch(e){} }; clr.onerror=()=>rej(clr.error); tx.oncomplete=()=>res(true); tx.onerror=()=>rej(tx.error) }) } }

function sha256(str){ return crypto.subtle.digest('SHA-256', new TextEncoder().encode(str)).then(buf=>{ const a=new Uint8Array(buf); return Array.from(a).map(b=>b.toString(16).padStart(2,'0')).join('') }) }
export async function resizeToDataUrl(file, size, mime, quality){ const max = size||128; const type = mime||'image/webp'; const q = typeof quality==='number'?quality:0.7; const img = await new Promise((res,rej)=>{ const r=new FileReader(); r.onload=()=>{ const i=new Image(); i.onload=()=>res(i); i.onerror=rej; i.src=r.result }; r.onerror=rej; r.readAsDataURL(file) }); const canvas=document.createElement('canvas'); const s=Math.min(img.width,img.height); const sx=(img.width-s)/2; const sy=(img.height-s)/2; canvas.width=max; canvas.height=max; const ctx=canvas.getContext('2d'); ctx.drawImage(img, sx, sy, s, s, 0, 0, max, max); return canvas.toDataURL(type, q) }

export class WriteQueue{ constructor(db){ this.db=db; this.pending=null; this.timer=null; this.attempts=0; const wq=(window.__CEDB&&window.__CEDB.writeQueue)||{}; this.min=wq.intervalMin||3000; this.max=wq.intervalMax||5000; this.locked=false; this.maxAttempts=5; this.lastBefore=null } pushSnapshot(data){ this.pending=JSON.stringify(data); this.schedule() } schedule(){ if(this.timer) return; const delay=Math.floor(this.min+Math.random()*(this.max-this.min)); this.timer=setTimeout(()=>{ this.timer=null; this.flush() }, delay) } async flush(){ if(!this.pending) return; if(!this.acquireLock()){ this.schedule(); return } try{ const prev=await this.db.adapter.read(); this.lastBefore=prev; const target=JSON.parse(this.pending); const sumBefore=await sha256(JSON.stringify(target)); const allowEmpty=Array.isArray(prev)&&prev.length>0&&Array.isArray(target)&&target.length===0; await this.db.adapter.write(target,{ allowEmpty }); const after=await this.db.adapter.read(); const sumAfter=await sha256(JSON.stringify(after)); if(sumBefore!==sumAfter) throw new Error('checksum_mismatch'); this.pending=null; this.attempts=0; this.releaseLock(); this.lastFlushAt=Date.now(); if(typeof this.db.onFlushed==='function') this.db.onFlushed(); }catch(err){ this.releaseLock(); this.attempts++; if(typeof this.db.onConflict==='function') this.db.onConflict(err); if(this.attempts>=this.maxAttempts) this.attempts=0; this.schedule() } } acquireLock(){ if(this.locked) return false; this.locked=true; return true } releaseLock(){ this.locked=false } }

export class DB{ constructor(adapter){ this.adapter=adapter; this.data=[]; this.queue=null } async load(){ const raw=await this.adapter.read(); this.data=Array.isArray(raw)?raw:[]; this.migrate(); return this.data } migrate(){ const byKey={}; this.data.forEach(r=>{ if(!r.prefix) r.prefix=(window.__CEDB&&window.__CEDB.defaultPrefix)||'app_'; if(typeof r.metavalue==='string'){ try{ r.metavalue=JSON.parse(r.metavalue) }catch(_){ } } const k=r.prefix+':'+(r.collection||''); if(!byKey[k]) byKey[k]=0; if(!r.relid){ byKey[k]++; r.relid=byKey[k] } else { byKey[k]=Math.max(byKey[k], Number(r.relid)||0) } if(!r.createddate&&r.datecreated) r.createddate=r.datecreated; if(!r.updateddate&&r.dateupdated) r.updateddate=r.dateupdated }) } list(filter){ let a=this.data.slice(); if(filter){ if(filter.prefix) a=a.filter(r=>r.prefix===filter.prefix); if(filter.collection) a=a.filter(r=>r.collection===filter.collection) } return a } get(id){ return this.data.find(r=>r.id===Number(id)) } async persist(){ if(this.queue) this.queue.pushSnapshot(this.data) } nextId(){ return (this.data.reduce((m,r)=>Math.max(m,Number(r.id)||0),0)||0)+1 } nextRelid(prefix,collection){ const a=this.data.filter(r=>r.prefix===prefix&&r.collection===collection); return a.reduce((m,r)=>Math.max(m,Number(r.relid)||0),0)+1 } async create(payload){ const prefix=(payload.prefix||(window.__CEDB&&window.__CEDB.defaultPrefix)||'app_'); const collection=payload.collection||''; const now=new Date().toISOString(); const id=this.nextId(); const relid=payload.relid?Number(payload.relid):this.nextRelid(prefix,collection); const metavalue=payload.metavalue&&typeof payload.metavalue==='object'? payload.metavalue : (payload.metavalue||''); const row={ id, relid, prefix, collection, metakey: payload.metakey||'', metavalue, createddate: now, updateddate: now }; this.data.push(row); await this.persist(); return row } async update(id,payload){ const row=this.get(id); if(!row) throw new Error('not_found'); Object.keys(payload||{}).forEach(k=>{ row[k]=payload[k] }); row.updateddate=new Date().toISOString(); await this.persist(); return row } async remove(id){ const n=Number(id); this.data=this.data.filter(r=>r.id!==n); await this.persist(); return true } }

export function buildAdapterFromConfig(cfg){ const c = cfg || window.__CEDB || {}; const headers=(c.headers)||{}; return new HttpAdapter({ url: c.writeUrl||c.url||'', method: c.writeMethod||'PUT', headers, snapshotUrl: c.snapshotUrl||c.url||'' }) }
